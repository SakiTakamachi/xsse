#include "../xsse_test.h"

static void test_mm_i32gather_epi32_1(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi32((int*) data, vindex, 1);

	int32_t expected[4] = { 0x05040302, 0x04030201, 0x06050403, 0xF7F80706 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i32gather_epi32_2(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi32((int*) data, vindex, 2);

	int32_t expected[4] = { 0x07060504, 0x05040302, 0xF7F80706, 0xF1F2F3F4 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i32gather_epi32_3(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi32((int*) data, vindex, 4);

	int32_t expected[4] = { 0xF5F6F7F8, 0x07060504, 0xF1F2F3F4, 0x0B0A0908 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i32gather_epi32_4(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi32((int*) data, vindex, 8);

	int32_t expected[4] = { 0xFDFEFF00, 0xF5F6F7F8, 0x0B0A0908, 0x2221201F };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i32gather_epi64_1(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi64((int64_t*) data, vindex, 1);

	int64_t expected[2] = { 0xF7F8070605040302, 0xF807060504030201 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i32gather_epi64_2(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi64((int64_t*) data, vindex, 2);

	int64_t expected[2] = { 0xF5F6F7F807060504, 0xF7F8070605040302 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i32gather_epi64_3(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi64((int64_t*) data, vindex, 4);

	int64_t expected[2] = { 0xF1F2F3F4F5F6F7F8, 0xF5F6F7F807060504 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i32gather_epi64_4(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);

	__m128i result = _mm_i32gather_epi64((int64_t*) data, vindex, 8);

	int64_t expected[2] = { 0xF9FAFBFCFDFEFF00, 0xF1F2F3F4F5F6F7F8 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi32_1(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_set_epi64x(5, 4);

	__m128i result = _mm_i64gather_epi32((int*) data, vindex, 1);

	int32_t expected[4] = { 0x07060504, 0xF8070605, 0, 0 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi32_2(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_set_epi64x(5, 4);

	__m128i result = _mm_i64gather_epi32((int*) data, vindex, 2);

	int32_t expected[4] = { 0xF5F6F7F8, 0xF3F4F5F6, 0, 0 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi32_3(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_set_epi64x(5, 4);

	__m128i result = _mm_i64gather_epi32((int*) data, vindex, 4);

	int32_t expected[4] = { 0xFDFEFF00, 0xF9FAFBFC, 0, 0 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi32_4(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m128i vindex = _mm_set_epi64x(5, 4);

	__m128i result = _mm_i64gather_epi32((int*) data, vindex, 8);

	int32_t expected[4] = { 0x12111000, 0x1A191817, 0, 0 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi64_1(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_set_epi64x(1, 2);

	__m128i result = _mm_i64gather_epi64((int64_t*) data, vindex, 1);

	int64_t expected[2] = { 0xF7F8070605040302, 0xF807060504030201 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi64_2(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_set_epi64x(1, 2);

	__m128i result = _mm_i64gather_epi64((int64_t*) data, vindex, 2);

	int64_t expected[2] = { 0xF5F6F7F807060504, 0xF7F8070605040302 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi64_3(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_set_epi64x(1, 2);

	__m128i result = _mm_i64gather_epi64((int64_t*) data, vindex, 4);

	int64_t expected[2] = { 0xF1F2F3F4F5F6F7F8, 0xF5F6F7F807060504 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_i64gather_epi64_4(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i vindex = _mm_set_epi64x(1, 2);

	__m128i result = _mm_i64gather_epi64((int64_t*) data, vindex, 8);

	int64_t expected[2] = { 0xF9FAFBFCFDFEFF00, 0xF1F2F3F4F5F6F7F8 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_mask_i32gather_epi32(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i src = _mm_setr_epi32(0x4A, 0x4B, 0x4C, 0x4D);
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);
	__m128i mask = _mm_setr_epi32(0, 1, -1, -2);

	__m128i result = _mm_mask_i32gather_epi32(src, (int*) data, vindex, mask, 1);

	int32_t expected[4] = { 0x4A, 0x4B, 0x06050403, 0xF7F80706 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_mask_i32gather_epi64(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i src = _mm_set_epi64x(0x4B, 0x4A);
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);
	__m128i mask = _mm_set_epi64x(-1, 0);

	__m128i result = _mm_mask_i32gather_epi64(src, (int64_t*) data, vindex, mask, 2);

	int64_t expected[2] = { 0x4A, 0xF7F8070605040302 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_mask_i64gather_epi32(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[32] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i src = _mm_setr_epi32(0x4A, 0x4B, 0x4C, 0x4D);
	__m128i vindex = _mm_set_epi64x(5, 4);
	__m128i mask = _mm_setr_epi32(-1, 2, 0, -1);

	__m128i result = _mm_mask_i64gather_epi32(src, (int*) data, vindex, mask, 4);

	int32_t expected[4] = { 0xFDFEFF00, 0x4B, 0, 0 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm_mask_i64gather_epi64(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F
	};
	__m128i src = _mm_set_epi64x(0x4B, 0x4A);
	__m128i vindex = _mm_set_epi64x(1, 2);
	__m128i mask = _mm_set_epi64x(-1, 0);

	__m128i result = _mm_mask_i64gather_epi64(src, (int64_t*) data, vindex, mask, 8);

	int64_t expected[2] = { 0x4A, 0xF1F2F3F4F5F6F7F8 };
	int64_t actual[2];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 2; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_i32gather_epi32(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i vindex = _mm256_setr_epi32(2, 1, 3, 3, 4, 5, 0, 3);

	__m256i result = _mm256_i32gather_epi32((int*) data, vindex, 1);

	int32_t expected[8] = {
		0x05040302, 0x04030201, 0x06050403, 0x06050403,
		0x07060504, 0xF8070605, 0x03020100, 0x06050403
	};
	int32_t actual[8];
	_mm256_storeu_si256((__m256i*) actual, result);

	for (int i = 0; i < 8; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_i32gather_epi64(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 3);

	__m256i result = _mm256_i32gather_epi64((int64_t*) data, vindex, 2);

	int64_t expected[4] = {
		0xF5F6F7F807060504, 0xF7F8070605040302, 0xF3F4F5F6F7F80706, 0xF3F4F5F6F7F80706
	};
	int64_t actual[4];
	_mm256_storeu_si256((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_i64gather_epi32_1(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i vindex = _mm256_setr_epi64x(2, 1, 3, 3);

	__m128i result = _mm256_i64gather_epi32((int*) data, vindex, 1);

	int32_t expected[4] = {
		0x05040302, 0x04030201, 0x06050403, 0x06050403
	};
	int32_t actual[4];
	_mm_storeu_si128((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_i64gather_epi32_2(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i vindex = _mm256_setr_epi64x(2, 1, 3, 3);

	__m128i result = _mm256_i64gather_epi32((int*) data, vindex, 2);

	int32_t expected[4] = {
		0x07060504, 0x05040302, 0xF7F80706, 0xF7F80706
	};
	int32_t actual[4];
	_mm_storeu_si128((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_i64gather_epi32_3(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i vindex = _mm256_setr_epi64x(2, 1, 3, 3);

	__m128i result = _mm256_i64gather_epi32((int*) data, vindex, 4);

	int32_t expected[4] = {
		0xF5F6F7F8, 0x07060504, 0xF1F2F3F4, 0xF1F2F3F4
	};
	int32_t actual[4];
	_mm_storeu_si128((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_i64gather_epi32_4(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i vindex = _mm256_setr_epi64x(2, 1, 3, 3);

	__m128i result = _mm256_i64gather_epi32((int*) data, vindex, 8);

	int32_t expected[4] = {
		0xFDFEFF00, 0xF5F6F7F8, 0x0B0A0908, 0x0B0A0908
	};
	int32_t actual[4];
	_mm_storeu_si128((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_i64gather_epi64(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i vindex = _mm256_setr_epi64x(2, 1, 3, 3);

	__m256i result = _mm256_i64gather_epi64((int64_t*) data, vindex, 8);

	int64_t expected[4] = {
		0xF9FAFBFCFDFEFF00, 0xF1F2F3F4F5F6F7F8,
		0x0F0E0D0C0B0A0908, 0x0F0E0D0C0B0A0908
	};
	int64_t actual[4];
	_mm256_storeu_si256((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_mask_i32gather_epi32(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i src = _mm256_setr_epi32(0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50, 0x51);
	__m256i vindex = _mm256_setr_epi32(2, 1, 3, 3, 4, 5, 0, 3);
	__m256i mask = _mm256_setr_epi32(0, 1, -1, -2, -1, 0, 10, -5);

	__m256i result = _mm256_mask_i32gather_epi32(src, (int*) data, vindex, mask, 1);

	int32_t expected[8] = {
		0x4A, 0x4B, 0x06050403, 0x06050403,
		0x07060504, 0x4F, 0x50, 0x06050403
	};
	int32_t actual[8];
	_mm256_storeu_si256((__m256i*) actual, result);

	for (int i = 0; i < 8; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_mask_i32gather_epi64(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i src = _mm256_setr_epi64x(0x4A, 0x4B, 0x4C, 0x4D);
	__m128i vindex = _mm_setr_epi32(2, 1, 3, 6);
	__m256i mask = _mm256_setr_epi64x(0, 1, -1, -2);

	__m256i result = _mm256_mask_i32gather_epi64(src, (int64_t*) data, vindex, mask, 2);

	int64_t expected[4] = {
		0x4A, 0x4B, 0xF3F4F5F6F7F80706, 0xFDFEFF00F1F2F3F4
	};
	int64_t actual[4];
	_mm256_storeu_si256((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_mask_i64gather_epi32(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m128i src = _mm_setr_epi32(0x4A, 0x4B, 0x4C, 0x4D);
	__m256i vindex = _mm256_setr_epi64x(2, 1, 3, 6);
	__m128i mask = _mm_setr_epi32(-1, 2, 0, -1);

	__m128i result = _mm256_mask_i64gather_epi32(src, (int*) data, vindex, mask, 4);

	int32_t expected[4] = { 0xF5F6F7F8, 0x4B, 0x4C, 0x0B0A0908 };
	int32_t actual[4];
	_mm_storeu_si128((__m128i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

static void test_mm256_mask_i64gather_epi64(void **state)
{
	(void) state;

#ifdef XSSE_AVX2
	int8_t data[64] = {
		0, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0xF8, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1,
		0, 0xFF, 0xFE, 0xFD, 0xFC, 0xFB, 0xFA, 0xF9, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
		0, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E,
		0x1F, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E
	};
	__m256i src = _mm256_setr_epi64x(0x4A, 0x4B, 0x4C, 0x4D);
	__m256i vindex = _mm256_setr_epi64x(2, 1, 3, 6);
	__m256i mask = _mm256_setr_epi64x(-1, 1, -1, -2);

	__m256i result = _mm256_mask_i64gather_epi64(src, (int64_t*) data, vindex, mask, 8);

	int64_t expected[4] = {
		0xF9FAFBFCFDFEFF00, 0x4B, 0x0F0E0D0C0B0A0908, 0x262524232221201F
	};
	int64_t actual[4];
	_mm256_storeu_si256((__m256i*) actual, result);

	for (int i = 0; i < 4; i++) {
		assert_int_equal(actual[i], expected[i]);
	}
#else
	skip();
#endif
}

int main(void)
{
	const struct CMUnitTest tests[] = {
		cmocka_unit_test(test_mm_i32gather_epi32_1),
		cmocka_unit_test(test_mm_i32gather_epi32_2),
		cmocka_unit_test(test_mm_i32gather_epi32_3),
		cmocka_unit_test(test_mm_i32gather_epi32_4),
		cmocka_unit_test(test_mm_i32gather_epi64_1),
		cmocka_unit_test(test_mm_i32gather_epi64_2),
		cmocka_unit_test(test_mm_i32gather_epi64_3),
		cmocka_unit_test(test_mm_i32gather_epi64_4),
		cmocka_unit_test(test_mm_i64gather_epi32_1),
		cmocka_unit_test(test_mm_i64gather_epi32_2),
		cmocka_unit_test(test_mm_i64gather_epi32_3),
		cmocka_unit_test(test_mm_i64gather_epi32_4),
		cmocka_unit_test(test_mm_i64gather_epi64_1),
		cmocka_unit_test(test_mm_i64gather_epi64_2),
		cmocka_unit_test(test_mm_i64gather_epi64_3),
		cmocka_unit_test(test_mm_i64gather_epi64_4),
		cmocka_unit_test(test_mm_mask_i32gather_epi32),
		cmocka_unit_test(test_mm_mask_i32gather_epi64),
		cmocka_unit_test(test_mm_mask_i64gather_epi32),
		cmocka_unit_test(test_mm_mask_i64gather_epi64),
		cmocka_unit_test(test_mm256_i32gather_epi32),
		cmocka_unit_test(test_mm256_i32gather_epi64),
		cmocka_unit_test(test_mm256_i64gather_epi32_1),
		cmocka_unit_test(test_mm256_i64gather_epi32_2),
		cmocka_unit_test(test_mm256_i64gather_epi32_3),
		cmocka_unit_test(test_mm256_i64gather_epi32_4),
		cmocka_unit_test(test_mm256_i64gather_epi64),
		cmocka_unit_test(test_mm256_mask_i32gather_epi32),
		cmocka_unit_test(test_mm256_mask_i32gather_epi64),
		cmocka_unit_test(test_mm256_mask_i64gather_epi32),
		cmocka_unit_test(test_mm256_mask_i64gather_epi64)
	};
	return cmocka_run_group_tests(tests, NULL, NULL);
}
